<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spanish Flashcards — Daily Decks + Unknown Deck</title>

<style>
  body {
    margin: 0;
    min-height: 100vh;
    background: #0b0b0b;
    color: #f3f3f3;
    font-family: system-ui, -apple-system, Helvetica, Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 18px;
  }

  .topbar {
    width: min(92vw, 900px);
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
  }

  .title {
    font-size: 1.05rem;
    opacity: 0.9;
  }

  select {
    background: #1f1f1f;
    color: #fff;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 14px;
    padding: 10px 12px;
    font-size: 0.95rem;
    font-weight: 650;
    cursor: pointer;
  }

  .card {
    width: min(92vw, 900px);
    height: min(55vh, 460px);
    background: #141414;
    border-radius: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 20px 50px rgba(0,0,0,0.45);
    padding: 32px;
    box-sizing: border-box;
    user-select: none;
    border: 1px solid rgba(255,255,255,0.10);
    position: relative;
  }

  .word {
    font-size: clamp(2.0rem, 5.6vw, 4.6rem);
    font-weight: 750;
    line-height: 1.15;
    word-break: break-word;
  }

  .label {
    margin-top: 12px;
    font-size: 0.95rem;
    opacity: 0.75;
  }

  .badge {
    position: absolute;
    top: 14px;
    right: 14px;
    padding: 8px 10px;
    border-radius: 999px;
    font-size: 0.9rem;
    font-weight: 750;
    display: none;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06);
  }
  .badge.show { display: inline-flex; }
  .badge.unknown {
    border-color: rgba(255,200,0,0.35);
    background: rgba(255,200,0,0.12);
  }

  .controls {
    margin-top: 18px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
  }

  button {
    background: #1f1f1f;
    color: #fff;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 14px;
    padding: 12px 18px;
    font-size: 1rem;
    font-weight: 650;
    cursor: pointer;
  }
  button:hover { opacity: 0.9; }

  button.unknownBtn {
    border-color: rgba(255,200,0,0.35);
  }
  button.unknownBtn.active {
    background: rgba(255,200,0,0.18);
    border-color: rgba(255,200,0,0.55);
  }

  .status {
    margin-top: 12px;
    font-size: 0.9rem;
    opacity: 0.82;
    text-align: center;
    width: min(92vw, 900px);
    line-height: 1.35;
  }

  .error {
    margin-top: 10px;
    width: min(92vw, 900px);
    padding: 10px 12px;
    border-radius: 12px;
    background: rgba(255,70,70,0.12);
    border: 1px solid rgba(255,70,70,0.35);
    display: none;
    white-space: pre-wrap;
    font-size: 0.95rem;
  }

  .tiny {
    margin-top: 10px;
    opacity: 0.65;
    font-size: 0.9rem;
    text-align: center;
  }
</style>
</head>

<body>

<div class="topbar">
  <div class="title">Spanish Flashcards — Daily Decks + “I Don’t Know” Deck</div>
  <div>
    <select id="deckSelect" title="Choose a deck"></select>
  </div>
</div>

<div class="card" id="card" title="Click to flip">
  <span class="badge unknown" id="unknownBadge">★ Unknown</span>
  <div>
    <div class="word" id="word">Loading…</div>
    <div class="label" id="label">Click to flip.</div>
  </div>
</div>

<div class="controls">
  <button id="prevBtn">← Prev</button>
  <button id="flipBtn">Flip</button>
  <button id="nextBtn">Next →</button>
  <button id="shuffleBtn">Shuffle</button>

  <button id="startBtn">Start: <span id="startSideLabel">EN</span></button>
  <button id="audioBtn">Audio: <span id="audioLabel">ON</span></button>

  <button id="unknownBtn" class="unknownBtn" title="Mark this card as unknown">★ I don’t know</button>
</div>

<div class="status" id="status"></div>
<div class="error" id="errorBox"></div>
<div class="tiny">Keys: Space=Flip · ←/→ navigate · U=mark unknown · S=shuffle · E=start side</div>

<script>
/* =========================
   SHOW JS ERRORS ON PAGE
   ========================= */
(function () {
  const errorBox = document.getElementById("errorBox");
  window.addEventListener("error", (e) => {
    errorBox.style.display = "block";
    errorBox.textContent = "JS ERROR:\n" + (e.message || "Unknown error");
  });
})();

/* =========================
   DATA: DAILY DECKS
   (Edit/add decks here)
   ========================= */
const DECKS = {
  "2026-01-28 — TODAY vocab (from PDF)": [
    { en: "hybrid identities", es: "identidades híbridas" },
    { en: "identity", es: "la identidad" },
    { en: "traditional music", es: "la música tradicional" },
    { en: "traditional musics", es: "las músicas tradicionales" },
    { en: "milonga (genre/song)", es: "la milonga" },
    { en: "stanza", es: "la estrofa" },
    { en: "popular stanzas", es: "estrofas populares" },

    { en: "coaster (under a cup)", es: "el posavasos" },
    { en: "décima (poetic form)", es: "la décima" },
    { en: "a poem of ten lines", es: "un poema de diez versos" },
    { en: "challenged (adj.)", es: "retado/a" },
    { en: "from Madrid (adj.)", es: "matritense" },

    { en: "a TED talk", es: "una charla TED" },
    { en: "to reflect (on)", es: "reflexionar (sobre)" },
    { en: "to relate (to)", es: "relacionarse (con)" },
    { en: "to write songs", es: "escribir canciones" },

    { en: "Uruguayan", es: "uruguayo/a" },
    { en: "round", es: "redondo/a" },
    { en: "bar", es: "el bar" },
    { en: "to jot down / write down", es: "anotar" },
    { en: "to add", es: "añadir" },

    { en: "Jewish", es: "judío/judía" },
    { en: "German", es: "alemán/alemana" },
    { en: "to escape", es: "escapar" },
    { en: "Nazi Germany", es: "la Alemania nazi" },

    { en: "surgeon", es: "cirujano/a" },
    { en: "profession", es: "la profesión" },
    { en: "to leave behind", es: "dejar" },
    { en: "to dedicate oneself to", es: "dedicarse a" },

    { en: "borrowed (adj.)", es: "prestado/a" },
    { en: "to impact / to affect", es: "impactar" },
    { en: "to confess", es: "confesar" },

    { en: "to realize", es: "darse cuenta (de)" },
    { en: "true passion", es: "la verdadera pasión" },
    { en: "to represent", es: "representar" },
    { en: "a challenge", es: "un desafío" },
    { en: "to accept", es: "aceptar" },
    { en: "to impress", es: "impresionar" },
    { en: "opportunity", es: "la oportunidad" },
    { en: "to express", es: "expresar" },
    { en: "feelings", es: "los sentimientos" },
    { en: "to articulate", es: "articular" },
    { en: "to highlight", es: "destacar" },
    { en: "complexity", es: "la complejidad" },
    { en: "humility", es: "la humildad" },
    { en: "willingness to learn", es: "la disposición a aprender" },

    { en: "conference / talk", es: "la conferencia" },
    { en: "subtitles", es: "los subtítulos" },
    { en: "to focus (on)", es: "centrarse (en)" },
    { en: "to write down / note", es: "apuntar" },
    { en: "new vocabulary", es: "el vocabulario nuevo" },

    { en: "history", es: "la historia" },
    { en: "spread / diffusion", es: "la difusión" },
    { en: "variety", es: "la variedad" },
    { en: "names", es: "los nombres" },
    { en: "evolution", es: "la evolución" },
    { en: "adaptation", es: "la adaptación" },
    { en: "local traditions", es: "las tradiciones locales" },
    { en: "to demonstrate / show", es: "demostrar" },
    { en: "to remain the same", es: "permanecer igual" },
    { en: "structure", es: "la estructura" },
    { en: "rhyme", es: "la rima" },
    { en: "syllables", es: "las sílabas" },
    { en: "listeners", es: "los oyentes" },
    { en: "to concentrate", es: "concentrarse" },
    { en: "meaning", es: "el significado" },
    { en: "musicality", es: "la musicalidad" },
    { en: "rhythm", es: "el ritmo" },
    { en: "to appreciate", es: "apreciar" },
    { en: "technical complexity", es: "la complejidad técnica" }
  ],

  "Template (EMPTY)": [
    { en: "add new words here", es: "añade palabras nuevas aquí" }
  ]
};

/* =========================
   UNKNOWN (“I don't know”) DECK (persisted)
   ========================= */
const UNKNOWN_DECK_KEY = "★ Unknown Deck (All 'I don’t know' cards)";
const LS_UNKNOWN_SET = "spanishFlashcards_unknownSet_v1";   // stores { [cardId]: {en,es} }
const LS_UNKNOWN_ORDER = "spanishFlashcards_unknownOrder_v1"; // stores [cardId,...] for stable order

function safeJSONParse(s, fallback) {
  try { return JSON.parse(s); } catch { return fallback; }
}

function loadUnknownState() {
  const setObj = safeJSONParse(localStorage.getItem(LS_UNKNOWN_SET), {});
  const order = safeJSONParse(localStorage.getItem(LS_UNKNOWN_ORDER), []);
  // prune order if missing in setObj
  const pruned = order.filter(id => setObj[id]);
  if (pruned.length !== order.length) {
    localStorage.setItem(LS_UNKNOWN_ORDER, JSON.stringify(pruned));
  }
  return { setObj, order: pruned };
}

function saveUnknownState(setObj, order) {
  localStorage.setItem(LS_UNKNOWN_SET, JSON.stringify(setObj));
  localStorage.setItem(LS_UNKNOWN_ORDER, JSON.stringify(order));
}

function cardId(card) {
  // stable id across decks: ES|EN (lowercased, trimmed)
  const es = (card.es || "").trim().toLowerCase();
  const en = (card.en || "").trim().toLowerCase();
  return `${es}|||${en}`;
}

function buildUnknownDeckFromStorage() {
  const { setObj, order } = loadUnknownState();
  return order.map(id => setObj[id]).filter(Boolean);
}

/* =========================
   APP STATE
   ========================= */
let deckKey = Object.keys(DECKS)[0];
let deck = [...DECKS[deckKey]];
let index = 0;

let startSide = "EN";          // "EN" or "ES"
let showingSpanish = false;    // current side showing
let audioOn = true;

/* =========================
   ELEMENTS
   ========================= */
const deckSelectEl = document.getElementById("deckSelect");
const cardEl = document.getElementById("card");
const wordEl = document.getElementById("word");
const labelEl = document.getElementById("label");
const statusEl = document.getElementById("status");
const startSideLabel = document.getElementById("startSideLabel");
const audioLabel = document.getElementById("audioLabel");
const unknownBtn = document.getElementById("unknownBtn");
const unknownBadge = document.getElementById("unknownBadge");

/* =========================
   AUDIO
   ========================= */
function speak(text, lang) {
  if (!audioOn) return;
  if (!("speechSynthesis" in window)) return;
  try {
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = lang;
    u.rate = 0.95;
    window.speechSynthesis.speak(u);
  } catch {}
}

/* =========================
   SHUFFLE
   ========================= */
function shuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

/* =========================
   DECK LOADING
   ========================= */
function getAllDeckKeysWithUnknownFirst() {
  const keys = Object.keys(DECKS);
  return [UNKNOWN_DECK_KEY, ...keys];
}

function getDeckCardsByKey(key) {
  if (key === UNKNOWN_DECK_KEY) return buildUnknownDeckFromStorage();
  return [...(DECKS[key] || [])];
}

function loadDeck(newKey) {
  deckKey = newKey;
  deck = getDeckCardsByKey(deckKey);
  index = 0;
  showingSpanish = (startSide === "ES");
  render();
}

/* =========================
   UNKNOWN TOGGLE
   ========================= */
function currentCard() {
  return deck[index];
}

function isCurrentCardUnknown() {
  const c = currentCard();
  if (!c) return false;
  const id = cardId(c);
  const { setObj } = loadUnknownState();
  return Boolean(setObj[id]);
}

function setUnknownUI() {
  const unknown = isCurrentCardUnknown();
  unknownBtn.classList.toggle("active", unknown);
  unknownBadge.classList.toggle("show", unknown);
}

function toggleUnknownForCurrentCard() {
  const c = currentCard();
  if (!c) return;

  const id = cardId(c);
  const state = loadUnknownState();
  const setObj = state.setObj;
  let order = state.order;

  if (setObj[id]) {
    // remove
    delete setObj[id];
    order = order.filter(x => x !== id);
  } else {
    // add
    setObj[id] = { en: c.en, es: c.es };
    if (!order.includes(id)) order.push(id);
  }

  saveUnknownState(setObj, order);

  // If currently viewing the Unknown deck, refresh it (and keep index in bounds)
  if (deckKey === UNKNOWN_DECK_KEY) {
    const prevId = c ? cardId(c) : null;
    deck = buildUnknownDeckFromStorage();
    if (deck.length === 0) {
      index = 0;
    } else if (prevId) {
      const newIdx = deck.findIndex(card => cardId(card) === prevId);
      index = newIdx >= 0 ? newIdx : 0;
    } else {
      index = 0;
    }
  }

  render();
}

/* =========================
   RENDER
   ========================= */
function render() {
  if (!deck.length) {
    wordEl.textContent = (deckKey === UNKNOWN_DECK_KEY)
      ? "No unknown cards yet"
      : "No cards";
    labelEl.textContent = (deckKey === UNKNOWN_DECK_KEY)
      ? "Mark cards with ★ “I don’t know” to build this deck."
      : "";
    statusEl.textContent = `Deck: ${deckKey} · 0 cards`;
    setUnknownUI();
    return;
  }

  const c = deck[index];
  const text = showingSpanish ? c.es : c.en;
  const lang = showingSpanish ? "es-ES" : "en-US";

  wordEl.textContent = text;
  labelEl.textContent = showingSpanish ? "Spanish" : "English";

  const audioStatus = ("speechSynthesis" in window)
    ? (audioOn ? "ON" : "OFF")
    : "Not supported";

  // unknown count
  const { order } = loadUnknownState();
  const unknownCount = order.length;

  statusEl.textContent =
    `Deck: ${deckKey} · Card ${index + 1}/${deck.length} · Unknown total: ${unknownCount} · Start: ${startSide} · Audio: ${audioStatus}`;

  setUnknownUI();
  speak(text, lang);
}

/* =========================
   ACTIONS
   ========================= */
function flipCard() {
  showingSpanish = !showingSpanish;
  render();
}
function nextCard() {
  if (!deck.length) return;
  index = (index + 1) % deck.length;
  showingSpanish = (startSide === "ES");
  render();
}
function prevCard() {
  if (!deck.length) return;
  index = (index - 1 + deck.length) % deck.length;
  showingSpanish = (startSide === "ES");
  render();
}
function shuffleDeck() {
  if (!deck.length) return;
  shuffleInPlace(deck);
  index = 0;
  showingSpanish = (startSide === "ES");
  render();
}
function toggleStart() {
  startSide = (startSide === "EN") ? "ES" : "EN";
  startSideLabel.textContent = startSide;
  showingSpanish = (startSide === "ES");
  render();
}
function toggleAudio() {
  audioOn = !audioOn;
  audioLabel.textContent = audioOn ? "ON" : "OFF";
  render();
}

/* =========================
   EVENTS
   ========================= */
document.getElementById("prevBtn").addEventListener("click", prevCard);
document.getElementById("flipBtn").addEventListener("click", flipCard);
document.getElementById("nextBtn").addEventListener("click", nextCard);
document.getElementById("shuffleBtn").addEventListener("click", shuffleDeck);
document.getElementById("startBtn").addEventListener("click", toggleStart);
document.getElementById("audioBtn").addEventListener("click", toggleAudio);
unknownBtn.addEventListener("click", toggleUnknownForCurrentCard);
cardEl.addEventListener("click", flipCard);

document.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  if (e.code === "Space") { e.preventDefault(); flipCard(); }
  else if (e.key === "ArrowRight") nextCard();
  else if (e.key === "ArrowLeft") prevCard();
  else if (k === "s") shuffleDeck();
  else if (k === "u") toggleUnknownForCurrentCard();
  else if (k === "e") toggleStart();
});

/* =========================
   INIT
   ========================= */
function init() {
  // Populate deck dropdown with Unknown deck + daily decks
  deckSelectEl.innerHTML = "";
  getAllDeckKeysWithUnknownFirst().forEach((k) => {
    const opt = document.createElement("option");
    opt.value = k;
    opt.textContent = k;
    deckSelectEl.appendChild(opt);
  });

  // Default: today deck (not Unknown) unless you want Unknown first
  deckKey = Object.keys(DECKS)[0];
  deckSelectEl.value = deckKey;

  deckSelectEl.addEventListener("change", (e) => loadDeck(e.target.value));

  startSideLabel.textContent = startSide;
  audioLabel.textContent = audioOn ? "ON" : "OFF";
  showingSpanish = (startSide === "ES");

  deck = getDeckCardsByKey(deckKey);
  render();
}

init();
</script>

</body>
</html>

